// -------------------------------------------------------------
//
// Module: filter
// Generated by MATLAB(R) 8.3 and the Filter Design HDL Coder 2.9.5.
// Generated on: 2015-01-14 03:35:23
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// TargetLanguage: Verilog
// TestBenchStimulus: impulse step ramp chirp noise 

// Filter Specifications:
//
// Sample Rate      : 64 MHz
// Response         : Highpass
// Specification    : N,Fc
// Filter Order     : 8
// Cutoff Frequency : 500 kHz
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Multipliers           : 1
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time FIR Filter (real)
// -------------------------------
// Filter Structure  : Direct-Form FIR
// Filter Length     : 9
// Stable            : Yes
// Linear Phase      : Yes (Type 1)
// Arithmetic        : fixed
// Numerator         : s4,2 -> [-2 2)
// Input             : s14,0 -> [-8192 8192)
// Filter Internals  : Specify Precision
//   Output          : s16,0 -> [-32768 32768)
//   Product         : s18,0 -> [-131072 131072)
//   Accumulator     : s24,0 -> [-8388608 8388608)
//   Round Mode      : round
//   Overflow Mode   : wrap
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Hhp800k
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [13:0] filter_in; //sfix14
  output  signed [15:0] filter_out; //sfix16

////////////////////////////////////////////////////////////////
//Module Architecture: filter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [3:0] coeff1 = 4'b0000; //sfix4_En2
  parameter signed [3:0] coeff2 = 4'b0000; //sfix4_En2
  parameter signed [3:0] coeff3 = 4'b0000; //sfix4_En2
  parameter signed [3:0] coeff4 = 4'b0000; //sfix4_En2
  parameter signed [3:0] coeff5 = 4'b0100; //sfix4_En2
  parameter signed [3:0] coeff6 = 4'b0000; //sfix4_En2
  parameter signed [3:0] coeff7 = 4'b0000; //sfix4_En2
  parameter signed [3:0] coeff8 = 4'b0000; //sfix4_En2
  parameter signed [3:0] coeff9 = 4'b0000; //sfix4_En2

  // Signals
  reg  signed [13:0] delay_pipeline [0:8] ; // sfix14
  wire signed [17:0] product5; // sfix18
  wire signed [15:0] output_typeconvert; // sfix16
  reg  signed [15:0] output_register; // sfix16

  // Block Statements
  always @( posedge clk or posedge reset)
    begin: Delay_Pipeline_process
      if (reset == 1'b1) begin
        delay_pipeline[0] <= 0;
        delay_pipeline[1] <= 0;
        delay_pipeline[2] <= 0;
        delay_pipeline[3] <= 0;
        delay_pipeline[4] <= 0;
        delay_pipeline[5] <= 0;
        delay_pipeline[6] <= 0;
        delay_pipeline[7] <= 0;
        delay_pipeline[8] <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline[0] <= filter_in;
          delay_pipeline[1] <= delay_pipeline[0];
          delay_pipeline[2] <= delay_pipeline[1];
          delay_pipeline[3] <= delay_pipeline[2];
          delay_pipeline[4] <= delay_pipeline[3];
          delay_pipeline[5] <= delay_pipeline[4];
          delay_pipeline[6] <= delay_pipeline[5];
          delay_pipeline[7] <= delay_pipeline[6];
          delay_pipeline[8] <= delay_pipeline[7];
        end
      end
    end // Delay_Pipeline_process


  assign product5 = $signed({{4{delay_pipeline[4][13]}}, delay_pipeline[4]});

  assign output_typeconvert = product5[15:0];

  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = output_register;
endmodule  // filter
